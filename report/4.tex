\chapter{ПРАКТИЧЕСКАЯ РАБОТА № 4}

\section{Тема}

Использование системных вызовов ОС

\section{Задание}

Реализовать код с использованием языка ассемблера, используя системные вызовы.

\section{Ход выполнения работы}

Системный вызов --- способ обращения программы пользовательского пространства к пространству ядра. Со стороны это может выглядеть как вызов обычной функции со своим собственным $calling$ $convention$, но на самом деле процессором выполняется чуть больше действий, чем при вызове функции инструкцией $call$. Например, в архитектуре $x86$ во время системного вызова как минимум происходит увеличение уровня привилегий, замена пользовательских сегментов на сегменты ядра и установка регистра $IP$ на обработчик системного вызова.

Программист обычно не работает с системными вызовами напрямую, так как системные вызовы обернуты в функции и скрыты в различных библиотеках, например, $libc.so$ в Linux или же $ntdll.dll$ в Windows, с которыми и взаимодействует прикладной разработчик.

Необходимо написать две функции: функцию $print$, которая выводит на экран принимаемые значения и функцию $itoa$, которая конвертирует число в строковое представление. Далее, используя вызовы, из функции $main$ нужно вызвать эти функции и посмотреть на результат. Исходный код функций приведен ниже. 

\begin{Verbatim}
itoa:
mov r8, 0
mov rax, rsi
mov ebx, 10
loop:
inc r8
mov edx, 0
div ebx
cmp rax, 0
jg loop
lea r9, [rdi + r8]
mov rax, rsi
loop2:
mov edx, 0
div ebx
add dl, '0'
dec r9
mov [r9], dl
cmp rax, 0
jg loop2
mov rax, r8
ret

print:
sub rsp, 56
mov rdx, rsi
mov rsi, rdi
mov rdi, 1
call write WRT ..plt
add rsp, 56
ret
\end{Verbatim}

Полный исходный код: https://github.com/ivanmakovetskiy/spo/blob/master/spo-main/syscall.asm
